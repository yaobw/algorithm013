HashMap学习笔记:
结构：数组+链表
其中数组是如下定义：
transient Node<K,V>[] table;

链表是由内部类K，V， nextNode来构成的
static class Node<K,V> implements Map.Entry<K,V> {
   final int hash;
   final K key;
   V value;
   Node<K,V> next;
   ...

因为没有记录beforeNode，因此是单向链表


hash算法的作用：是解决Node落点位置，具体过程为：key.getHashCode()高16位^低16位得到一个结果值
static final int hash(Object key) {
   int h;
   return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

HashMap put过程
1.先判断是否数组时空，为空，则默认创建长度为16的数组使用方法resize（）
2.通过hash算法得到的值与上（数组长度-1）得到数组角标，并判断是否该数组上是否有值
如果没有值，则直接将Node放在这个数组节点上
3.如果有值，则查看当前Node.next==null是否成立，如果成立，则创建新的Node，将K，V放在此节点下，并设置next为null；如果不为空，则循环链表，只到一个Node.next为空
4.当链表长度大于8时，会自动默认转化为红黑树。
5.当数组占用率达到扩容因子0.75的时候，会自动扩容，使用方法resize（）2倍扩容
6.扩容的位置计算
如果只有数组，没有链表，则直接放置
如果是红黑树，通过split方法重新定义位置，当树叶子结点小于6时，转换为链表结构
如果是链表，则通过hash值和老数组长度与运算得到结果如果与运算是1的话，则位置落到当前数组位置+扩容长度的数组位置

HashMap线程不安全的原因：
put的时候导致的多线程数据不一致
比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的 hash桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的 hash桶索引和线程B要插入的记录计算出来的 hash桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。

resize而引起死循环
这种情况发生在HashMap自动扩容时，当2个线程同时检测到元素个数超过 数组大小 × 负载因子。此时2个线程会在put()方法中调用了resize()，两个线程同时修改一个链表结构会产生一个循环链表（JDK1.7中，会出现resize前后元素顺序倒置的情况）。接下来再想通过get()获取某一个元素，就会出现死循环。